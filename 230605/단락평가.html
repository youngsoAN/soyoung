<script>
  /*
    단락평가(단락회로평가) : 논리 연산자의 특성을 이용하여 평가

    truthy: 참인듯?
      ㄴ 빈배열[], 빈객체{}.....
    falsy(falsey): 거짓인듯?
      ㄴ false, 0, -0(-1,-2..), '', null, undefined, NaN...

    boolean && 실행문, boolean || 실행문
    || OR 연산자
    true || 조건 -> A조건이 참이면 B 조건(실행문) 실행 x
    false || 조건 -> A조건이 거짓이면 B 조건(실행문) 실행 (내용 반환)

    && AND 연산자
    true && 조건 -> B조건도 참이면 실행
    false && 조건 -> A조건이 거짓이면 B 조건(실행문) 실행 x
  */

  console.log(false && true);// false
  // A의 값이 거짓인 경우 B의 값을 탐색할 필요도 없이 거짓이 되므로 falsy
  false && console.log('A가 거짓이면 이 내용은 반환되지 않음');
  true && console.log('A가 참이면 이 내용은 반환됨');

  console.log(true && false && true);// false
  // A와 B의 값이 false이기 때문에 때문에 C까지 가지 않고 멈춤 (falsey현상)
  console.log(true || false);// true
  // A값이 true인 경우 B의 값을 탐색할 필요가 없으므로 truthy
  true || console.log('A가 참이면 이 내용은 반환되지 않음');
  false || console.log('A가 거짓이면 이 내용은 반환됨');

  console.log(false || true || true);// true
  // A || B 먼저 연산 후 결과값을 C와 연산
  // A와 B를 읽어 true가 나오면 C의 값을 탐색할 필요가 없으므로 멈춤 truthy

  console.log('' || 'a');// a -> true, false로 연산 후 원래 값으로 반환
  // 빈 문자열의 경우 falsey의 값이므로 뒤의 값까지 읽어야 함
  console.log('' || 'a' || 222);// a
  // ''와 'a' 연산 후 a 가 참인듯한 상황이기 때문에 222까지 넘어가지 않고 truthy를 만나는 순간(a) 멈춤

  console.log([] && '' && 222);// ''
  // [] 참인듯, '' 거짓인듯 한 값이기 때문에 222로 넘어가지 않아도 falsey라는 것을 판단할 수 있기 때문에 ''에서 멈춤
  console.log([] && {} && 222);// 222
</script>