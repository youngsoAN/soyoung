<script>
  // 배열Array2

  console.log('인덱스 번호로 추가-------------');
  let arr1 = [
    { id: 1, coffee: '아메리카노' },
    { id: 2, coffee: '카페라떼' },
    { id: 3, coffee: '바닐라라떼' },
  ];
  console.log(arr1);
  console.log(arr1[1]);// {id: 2, coffee: '카페라떼'}
  console.log(arr1[1].coffee);// 카페라떼
  arr1[5] = 'string';
  console.log(arr1);// 인덱스3,4는 비워두고 5번에 추가. => (6) [{…}, {…}, {…}, empty × 2, 'string']
  console.log(arr1.length);// 6

  console.log('.push() 배열의 제일 마지막에 추가 ---');
  arr1.push({ id: 6, coffee: '카페모카' });
  console.log(arr1);

  console.log('.unshift() 배열의 제일 처음에 추가 ---');
  arr1.unshift({ id: 0, coffee: '오늘의 커피' });
  console.log(arr1);

  console.log('.concat() 둘 이상의 배열 연결 ---');
  /*
    1. 기존 배열 요소(원본)를 건드리지 않고 새로운 배열을 만들어 반환
    즉 새로운 Array 객체로 반환
    2. 기존 배열에 요소를 추가할 때 사용(복사본으로 반환)
  */
  let arr2 = [1, 2, 3, 4];
  let arr2a = arr2.concat();
  let arr2b = arr2.concat(40, 50, 60);
  let arr2c = arr2.concat('아메리카노', '카페라떼');

  console.log(arr2);// (4) [1, 2, 3, 4]
  console.log(arr2a);// (4) [1, 2, 3, 4] 새로운 배열로 반환
  console.log(arr2b);// (7) [1, 2, 3, 4, 40, 50, 60]
  console.log(arr2c);// (6) [1, 2, 3, 4, '아메리카노', '카페라떼']
  console.log(arr2c.concat(arr2c));// arr2+ arr2c -> 새로운 배열로 반환
  console.log(`arr2 원본: ${arr2}`);// arr2 원본: 1,2,3,4 원본 유지

  console.log('.join() 배열 안의 요소를 매개변수로 연결');
  console.log(arr2a.join('/'));// 1/2/3/4

  console.log('.splice(시작인덱스[, 요소의 수, 대체요소]) 특정 항목 삭제 및 대체');
  console.log(arr2c.splice(0, 5));// 인덱스 0번부터 5번 전까지 추출
  console.log(arr2c);// ['카페라떼'] 외에 것은 삭제됨

  console.log('.slice(시작인덱스, 마지막인덱스) 시작 인덱스 부터 마지막 인덱스 전까지 추출');
  // 새로운 배열로 반환하기 때문에 원본 배열 값 유지
  let arr3 = [10, 20, 30, 40, 50];
  console.log(arr3.slice(0, 3));// (3) [10, 20, 30]
  console.log(arr3);// (5) [10, 20, 30, 40, 50] 원본 살아있음

  console.log('delete 키워드: 요소의 값만 제거');
  console.log(delete arr3[2]);// true 삭제됨
  console.log(arr3);// (5) [10, 20, empty, 40, 50] 3번 삭제 됨
</script>